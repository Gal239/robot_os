#!/usr/bin/env python3
"""
LEVEL 1K: Object Placement & Orientation
=========================================
Clean MOP demonstrations: semantic placement, orientation control, self-validation
"""

import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))

from core.main.experiment_ops_unified import ExperimentOps


def test_surface_positions():
    """Surface Positioning: 7 positions on table"""

    ops = ExperimentOps(mode="simulated", headless=True, render_mode="rl_core")
    ops.create_scene(name="surface_test", width=8, length=8, height=3)
    ops.add_asset("table", relative_to=(3, 0, 0))
    ops.add_robot("stretch", position=(0, 0, 0), orientation="east")

    ops.add_asset("apple", asset_id="apple_tl", relative_to="table", relation="on_top", surface_position="top_left")
    ops.add_asset("apple", asset_id="apple_tr", relative_to="table", relation="on_top", surface_position="top_right")
    ops.add_asset("apple", asset_id="apple_bl", relative_to="table", relation="on_top", surface_position="bottom_left")
    ops.add_asset("apple", asset_id="apple_br", relative_to="table", relation="on_top", surface_position="bottom_right")
    ops.add_asset("apple", asset_id="apple_c", relative_to="table", relation="on_top", surface_position="center")

    ops.compile()
    ops.step()
    ops.step()
    ops.step()

    state = ops.get_state()
    print(f"\n  apple_tl: {state['apple_tl']['body'].get('stacked_on_table')}")
    print(f"  apple_tr: {state['apple_tr']['body'].get('stacked_on_table')}")
    print(f"  apple_bl: {state['apple_bl']['body'].get('stacked_on_table')}")
    print(f"  apple_br: {state['apple_br']['body'].get('stacked_on_table')}")
    print(f"  apple_c: {state['apple_c']['body'].get('stacked_on_table')}")

    ops.close()
    return True


def test_cardinal_orientations_north():
    """Cardinal North: Robot facing north"""

    ops = ExperimentOps(mode="simulated", headless=True, render_mode="rl_core")
    ops.create_scene(name="orient_north", width=8, length=8, height=3)
    ops.add_asset("table", relative_to=(3, 0, 0))
    ops.add_asset("apple", relative_to="table", relation="on_top")
    ops.add_robot("stretch", position=(0, 0, 0), orientation="north")
    ops.compile()

    result = ops.is_facing("stretch.arm", "apple")
    print(f"  NORTH: dot={result['dot']:+.3f} | {result['dot_class']}")

    ops.close()
    return True


def test_cardinal_orientations_south():
    """Cardinal South: Robot facing south"""

    ops = ExperimentOps(mode="simulated", headless=True, render_mode="rl_core")
    ops.create_scene(name="orient_south", width=8, length=8, height=3)
    ops.add_asset("table", relative_to=(3, 0, 0))
    ops.add_asset("apple", relative_to="table", relation="on_top")
    ops.add_robot("stretch", position=(0, 0, 0), orientation="south")
    ops.compile()

    result = ops.is_facing("stretch.arm", "apple")
    print(f"  SOUTH: dot={result['dot']:+.3f} | {result['dot_class']}")

    ops.close()
    return True


def test_cardinal_orientations_east():
    """Cardinal East: Robot facing east"""

    ops = ExperimentOps(mode="simulated", headless=True, render_mode="rl_core")
    ops.create_scene(name="orient_east", width=8, length=8, height=3)
    ops.add_asset("table", relative_to=(3, 0, 0))
    ops.add_asset("apple", relative_to="table", relation="on_top")
    ops.add_robot("stretch", position=(0, 0, 0), orientation="east")
    ops.compile()

    result = ops.is_facing("stretch.arm", "apple")
    print(f"  EAST: dot={result['dot']:+.3f} | {result['dot_class']}")

    ops.close()
    return True


def test_cardinal_orientations_west():
    """Cardinal West: Robot facing west"""

    ops = ExperimentOps(mode="simulated", headless=True, render_mode="rl_core")
    ops.create_scene(name="orient_west", width=8, length=8, height=3)
    ops.add_asset("table", relative_to=(3, 0, 0))
    ops.add_asset("apple", relative_to="table", relation="on_top")
    ops.add_robot("stretch", position=(0, 0, 0), orientation="west")
    ops.compile()

    result = ops.is_facing("stretch.arm", "apple")
    print(f"  WEST: dot={result['dot']:+.3f} | {result['dot_class']}")

    ops.close()
    return True


def test_stacking_chain():
    """Stacking Chain: 3 blocks vertically"""

    ops = ExperimentOps(mode="simulated", headless=True, render_mode="rl_core")
    ops.create_scene(name="stack_chain", width=8, length=8, height=3)
    ops.add_asset("table", relative_to=(3, 0, 0))
    ops.add_robot("stretch", position=(0, 0, 0), orientation="east")

    ops.add_asset("wood_block", asset_id="block1", relative_to="table", relation="on_top", surface_position="center")
    ops.add_asset("wood_block", asset_id="block2", relative_to="block1", relation="on_top", surface_position="center")
    ops.add_asset("wood_block", asset_id="block3", relative_to="block2", relation="on_top", surface_position="center")

    ops.add_reward("block1", behavior="stacked_on", target="table", reward=100, id="b1_table")
    ops.add_reward("block2", behavior="stacked_on", target="block1", reward=100, id="b2_b1")
    ops.add_reward("block3", behavior="stacked_on", target="block2", reward=100, id="b3_b2")

    ops.compile()
    ops.step()
    ops.step()
    ops.step()

    result = ops.validate_semantics(
        expected_stacked=[
            {'stacked_object': 'block1', 'stacked_on': 'table'},
            {'stacked_object': 'block2', 'stacked_on': 'block1'},
            {'stacked_object': 'block3', 'stacked_on': 'block2'},
        ]
    )

    print(f"\n  Stacking valid: {result['valid']}")
    ops.close()
    return True


def test_horizontal_arrangement():
    """Horizontal Arrangement: 4 objects next_to each other"""

    ops = ExperimentOps(mode="simulated", headless=True, render_mode="rl_core")
    ops.create_scene(name="horizontal", width=12, length=8, height=3)
    ops.add_asset("table", relative_to=(4, 0, 0))
    ops.add_robot("stretch", position=(0, 0, 0), orientation="east")

    ops.add_asset("apple", asset_id="obj1", relative_to="table", relation="on_top", surface_position="center")
    ops.add_asset("banana", asset_id="obj2", relative_to="obj1", relation="next_to", distance=0.15)
    ops.add_asset("orange", asset_id="obj3", relative_to="obj2", relation="next_to", distance=0.15)
    ops.add_asset("mug", asset_id="obj4", relative_to="obj3", relation="next_to", distance=0.15)

    ops.add_reward("obj1", behavior="stacked_on", target="table", reward=100, id="obj1_table")
    ops.add_reward("obj2", behavior="stacked_on", target="table", reward=100, id="obj2_table")
    ops.add_reward("obj3", behavior="stacked_on", target="table", reward=100, id="obj3_table")
    ops.add_reward("obj4", behavior="stacked_on", target="table", reward=100, id="obj4_table")

    ops.compile()
    ops.step()
    ops.step()
    ops.step()

    result12 = ops.get_distance("obj1", "obj2")
    result23 = ops.get_distance("obj2", "obj3")
    result34 = ops.get_distance("obj3", "obj4")

    print(f"\n  Distance 1->2: {result12['horizontal_distance']:.3f}m")
    print(f"  Distance 2->3: {result23['horizontal_distance']:.3f}m")
    print(f"  Distance 3->4: {result34['horizontal_distance']:.3f}m")

    ops.close()
    return True


def test_containment_hierarchy():
    """Containment: Bowl with 3 fruits inside"""

    ops = ExperimentOps(mode="simulated", headless=True, render_mode="rl_core")
    ops.create_scene(name="containment", width=8, length=8, height=3)
    ops.add_asset("table", relative_to=(3, 0, 0))
    ops.add_robot("stretch", position=(0, 0, 0), orientation="east")

    ops.add_asset("bowl", relative_to="table", relation="on_top", surface_position="center")
    ops.add_asset("strawberry", asset_id="strawberry", relative_to="bowl", relation="inside", surface_position="bottom")
    ops.add_asset("lemon", asset_id="lemon", relative_to="bowl", relation="inside", surface_position="bottom")
    ops.add_asset("peach", asset_id="peach", relative_to="bowl", relation="inside", surface_position="bottom")

    ops.add_reward("bowl", behavior="stacked_on", target="table", reward=100, id="bowl_table")

    ops.compile()
    ops.step()
    ops.step()
    ops.step()

    state = ops.get_state()
    bowl_state = state["bowl"]["body"]

    print(f"\n  Bowl contains cherry: {'containing_cherry' in bowl_state}")
    print(f"  Bowl contains grape: {'containing_grape' in bowl_state}")
    print(f"  Bowl contains blueberry: {'containing_blueberry' in bowl_state}")

    ops.close()
    return True


def test_facing_validation():
    """Facing: Robot checks 3 targets"""

    ops = ExperimentOps(mode="simulated", headless=True, render_mode="rl_core")
    ops.create_scene(name="facing_test", width=10, length=10, height=3)
    ops.add_asset("table", relative_to=(3, 0, 0))
    ops.add_robot("stretch", position=(0, 0, 0), orientation="east")

    ops.add_asset("apple", asset_id="target1", relative_to="table", relation="on_top", surface_position="center")
    ops.add_asset("banana", asset_id="target2", relative_to="table", relation="on_top", surface_position="top_left")
    ops.add_asset("orange", asset_id="target3", relative_to="table", relation="on_top", surface_position="bottom_right")

    ops.compile()

    result1 = ops.is_facing("stretch.arm", "target1")
    result2 = ops.is_facing("stretch.arm", "target2")
    result3 = ops.is_facing("stretch.arm", "target3")

    print(f"\n  target1: {result1['dot_explain']}")
    print(f"           dot={result1['dot']:+.3f}, dist={result1['distance']:.2f}m")
    print(f"\n  target2: {result2['dot_explain']}")
    print(f"           dot={result2['dot']:+.3f}, dist={result2['distance']:.2f}m")
    print(f"\n  target3: {result3['dot_explain']}")
    print(f"           dot={result3['dot']:+.3f}, dist={result3['distance']:.2f}m")

    ops.close()
    return True


def test_offset_placement():
    """Offset: Fine-tune positions with offset parameter"""

    ops = ExperimentOps(mode="simulated", headless=True, render_mode="rl_core")
    ops.create_scene(name="offset_test", width=8, length=8, height=3)
    ops.add_asset("table", relative_to=(3, 0, 0))
    ops.add_robot("stretch", position=(0, 0, 0), orientation="east")

    ops.add_asset("apple", asset_id="center", relative_to="table", relation="on_top", surface_position="center")
    ops.add_asset("banana", asset_id="offset_x", relative_to="center", relation="on_top", offset=(0.2, 0, 0))
    ops.add_asset("orange", asset_id="offset_y", relative_to="center", relation="on_top", offset=(0, 0.2, 0))
    ops.add_asset("mug", asset_id="offset_xy", relative_to="center", relation="on_top", offset=(0.15, 0.15, 0))

    ops.compile()
    ops.step()
    ops.step()
    ops.step()

    offset_x = ops.get_offset("center", "offset_x")
    offset_y = ops.get_offset("center", "offset_y")

    print(f"\n  X offset: {offset_x['dx']:.3f}m")
    print(f"  Y offset: {offset_y['dy']:.3f}m")

    ops.close()
    return True


def test_robot_grasp_alignment():
    """Grasp: Robot at table's wider side, arm facing apple"""

    ops = ExperimentOps(mode="simulated", headless=True, render_mode="rl_core")
    ops.create_scene(name="grasp_alignment", width=8, length=8, height=3)
    ops.add_asset("table", relative_to=(2, 0, 0))
    ops.add_asset("apple", relative_to="table", relation="on_top", surface_position="center")
    ops.add_robot("stretch", position=(2, -1.0, 0), orientation="south")

    ops.compile()

    result = ops.is_facing("stretch.arm", "apple")
    state = ops.get_state()
    arm = state["stretch"]["arm"]

    print(f"\n  {result['dot_explain']}")
    print(f"  Dot: {result['dot']:.3f}")
    print(f"  Distance: {result['distance']:.2f}m")
    print(f"  Arm direction: [{arm['direction'][0]:.2f}, {arm['direction'][1]:.2f}, {arm['direction'][2]:.2f}]")
    print(f"  Facing: {result['facing']}")

    ops.close()
    return True


if __name__ == "__main__":
    tests = [
        ("Surface Positions", test_surface_positions),
        ("Cardinal North", test_cardinal_orientations_north),
        ("Cardinal South", test_cardinal_orientations_south),
        ("Cardinal East", test_cardinal_orientations_east),
        ("Cardinal West", test_cardinal_orientations_west),
        ("Stacking Chain", test_stacking_chain),
        ("Horizontal Arrangement", test_horizontal_arrangement),
        ("Containment Hierarchy", test_containment_hierarchy),
        ("Facing Validation", test_facing_validation),
        ("Offset Placement", test_offset_placement),
        ("Robot Grasp Alignment", test_robot_grasp_alignment),
    ]

    print("\n" + "="*70)
    print("LEVEL 1K: OBJECT PLACEMENT & ORIENTATION")
    print("="*70)

    choice = input(f"\nRun all tests? (y/n): ").strip().lower()

    if choice == "y":
        print("\n" + "="*70)
        passed = 0
        test_surface_positions()
        passed += 1
        test_cardinal_orientations_north()
        passed += 1
        test_cardinal_orientations_south()
        passed += 1
        test_cardinal_orientations_east()
        passed += 1
        test_cardinal_orientations_west()
        passed += 1
        test_stacking_chain()
        passed += 1
        test_horizontal_arrangement()
        passed += 1
        test_containment_hierarchy()
        passed += 1
        test_facing_validation()
        passed += 1
        test_offset_placement()
        passed += 1
        test_robot_grasp_alignment()
        passed += 1

        print("\n" + "="*70)
        print(f"Results: {passed}/{len(tests)} completed")
        print("="*70)
    else:
        print("Cancelled")