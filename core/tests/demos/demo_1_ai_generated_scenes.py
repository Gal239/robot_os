#!/usr/bin/env python3
"""
AI-GENERATED SCENE LIBRARY - Clean API Demonstrations
======================================================
All scenarios generated by Claude AI after seeing breakfast scene ONCE.
Demonstrates semantic DSL capabilities without manual coordinates.
"""

import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))

from core.main.experiment_ops_unified import ExperimentOps


# ============================================================================
# NOTE: Validation now uses ops.validate_semantics() with expected_stacked param
# This is the MOP-compliant way - validation logic lives in ExperimentOps!
# ============================================================================

def test_0_breakfast_scene():
    """Breakfast Scene: Surface positioning demo with multiple objects on table"""

    # Scene setup
    ops = ExperimentOps(mode="simulated", headless=True, render_mode="2k_demo", save_fps=30)
    ops.create_scene(name="breakfast_scene", width=8, length=8, height=3)
    ops.add_asset(asset_name="table", relative_to=(2.0, 0.0, 0.0))  # Table at east
    ops.add_robot(robot_name="stretch", position=(0, 0, 0), orientation="facing_table")  # MOP: Robot faces west!

    # Place objects using surface_position (MOP: auto-calculates everything!)
    ops.add_asset(asset_name="apple", relative_to="table", relation="on_top", surface_position="top_left")
    ops.add_asset(asset_name="banana", relative_to="table", relation="on_top", surface_position="center")
    ops.add_asset(asset_name="mug", relative_to="table", relation="on_top", surface_position="top_right")
    ops.add_asset(asset_name="bowl", relative_to="table", relation="on_top", surface_position="bottom_left")
    ops.add_asset(asset_name="plate", relative_to="table", relation="on_top", surface_position="bottom_right")
    ops.add_asset(asset_name="spoon", relative_to="table", relation="on_top", offset=(0.0, -0.4, 0))  # Move away from center
    ops.add_asset(asset_name="orange", relative_to="table", relation="on_top", offset=(-0.4, 0.0, 0))  # Move away from center

    # Rewards for all objects on table
    ops.add_reward(tracked_asset="apple", behavior="stacked_on", target="table", reward=100, id="apple_on_table")
    ops.add_reward(tracked_asset="banana", behavior="stacked_on", target="table", reward=100, id="banana_on_table")
    ops.add_reward(tracked_asset="mug", behavior="stacked_on", target="table", reward=100, id="mug_on_table")
    ops.add_reward(tracked_asset="bowl", behavior="stacked_on", target="table", reward=100, id="bowl_on_table")
    ops.add_reward(tracked_asset="plate", behavior="stacked_on", target="table", reward=100, id="plate_on_table")
    ops.add_reward(tracked_asset="spoon", behavior="stacked_on", target="table", reward=100, id="spoon_on_table")
    ops.add_reward(tracked_asset="orange", behavior="stacked_on", target="table", reward=100, id="orange_on_table")

    # ===== TRACKING CAMERAS=====
    print("\n  Adding TRACKING cameras (follow each object)...")
    ops.add_free_camera(camera_id="track_table", track_target="table", distance=1.5, azimuth=135,elevation=-30)  # TODO: Fix furniture tracking
    ops.add_free_camera(camera_id="track_apple", track_target="apple", distance=1.0, azimuth=45, elevation=-20)
    ops.add_free_camera(camera_id="track_banana", track_target="banana", distance=1.0, azimuth=90, elevation=-20)
    ops.add_free_camera(camera_id="track_mug", track_target="mug", distance=1.0, azimuth=135, elevation=-20)
    ops.add_free_camera(camera_id="track_bowl", track_target="bowl", distance=2, azimuth=180, elevation=-15)

    # ===== CINEMATIC CAMERAS=====
    ops.add_overhead_camera()  # Automatically calculates lookat, distance, azimuth, elevation!
    ops.add_free_camera("side_cam", lookat=(2.0, 0.0, 0.8), distance=2.5, azimuth=90, elevation=-20)
    ops.add_free_camera("robot_pov_cam", lookat=(2.0, 0.0, 0.8), distance=1.5, azimuth=0, elevation=-10)
    ops.add_free_camera("robot_cam", lookat=(1.0, 0.0, 0.5), distance=3.0, azimuth=135, elevation=-20)
    ops.compile()

    for _ in range(200):
        ops.step()

    # MOP-compliant validation using expected_stacked - EXPLICIT JSON FORMAT!
    print("\n  Validating breakfast scene...")
    result = ops.validate_semantics(
        expected_stacked=[
            {'stacked_object': 'apple', 'stacked_on': 'table'},
            {'stacked_object': 'banana', 'stacked_on': 'table'},
            {'stacked_object': 'mug', 'stacked_on': 'table'},
            {'stacked_object': 'bowl', 'stacked_on': 'table'},
            {'stacked_object': 'plate', 'stacked_on': 'table'},
            {'stacked_object': 'spoon', 'stacked_on': 'table'},
            {'stacked_object': 'orange', 'stacked_on': 'table'}
        ]
    )
    print(f"\n‚úÖ PASS: Breakfast scene validated successfully!")
    print(result)


    # Save visual evidence
    ops.save_all_screenshots(frame=10, subdir="breakfast_screenshots")
    ops.close()

    # Validate videos
    print("\n  Validating videos...")
    ops.validate_videos(timeout=180)
    video_result = ops.validate_video_files()

    # Print results
    videos_dir = Path(ops.experiment_dir) / "timeline" / "cameras"
    screenshots_dir = Path(ops.experiment_dir) / "breakfast_screenshots"

    print("\n" + "="*70)
    print("BREAKFAST SCENE VALIDATION")
    print("="*70)
    print(f"\nScreenshots: {screenshots_dir}")
    print(f"Videos:      {videos_dir}")
    print(f"\nView Results:")
    print(f"  eog {screenshots_dir}/*.jpg")
    print(f"  vlc {videos_dir}/track_apple/track_apple_rgb.mp4")

    if result['valid'] and video_result['valid']:
        print(f"\n‚úÖ PASS: All 7 objects on table verified!")
        return True
    else:
        print(f"\n‚ùå FAIL: Breakfast scene validation failed")
        return False



def test_1_tower_stacking():
    """Tower Stacking: 4 blocks vertically stacked with stability tracking"""

    # Scene setup
    ops = ExperimentOps(mode="simulated", headless=True, render_mode="2k_demo", save_fps=30)
    ops.create_scene(name="tower_scene", width=6, length=6, height=4)
    ops.add_robot(robot_name="stretch", position=(0, 0, 0))
    ops.add_asset(asset_name="table", relative_to=(2.0, 0.0, 0.0))

    # Vertical stacking (semantic on_top relation) - SAME asset type with unique IDs!
    ops.add_asset(asset_name="wood_block", asset_id="block1", relative_to="table", relation="on_top", surface_position="center")
    ops.add_asset(asset_name="wood_block", asset_id="block2", relative_to="block1", relation="on_top", surface_position="center")


    # Each level must support the one above
    ops.add_reward(tracked_asset="block1", behavior="stacked_on", target="table", reward=100, id="block1_table")
    ops.add_reward(tracked_asset="block2", behavior="stacked_on", target="block1", reward=100, id="block2_on_block1")


    # Stability rewards
    ops.add_reward(tracked_asset="block1", behavior="stable", target=True, reward=50, id="red_stable")
    ops.add_reward(tracked_asset="block2", behavior="stable", target=True, reward=50, id="blue_stable")

    # Collapse penalties
    ops.add_reward(tracked_asset="block1", behavior="stacked_on", target="floor", reward=-100, id="block1_fell")
    ops.add_reward(tracked_asset="block2", behavior="stacked_on", target="floor", reward=-100, id="block2_fell")


    # Multi-angle camera system
    ops.add_overhead_camera()
    ops.add_free_camera(camera_id="tower_close", track_target="block1", distance=1.5, azimuth=45, elevation=-25)
    ops.add_free_camera(camera_id="tower_side", lookat=(2.0, 0.0, 1.0), distance=3.0, azimuth=90, elevation=-15)

    ops.compile()

    print("\n  Running simulation (500 steps)...")
    for _ in range(1000):
        ops.step()

    # SELF-VALIDATION: MOP-compliant validate_semantics with NEW EXPLICIT format!
    print("\n  Validating tower stacking...")
    result = ops.validate_semantics(
        expected_stacked=[
            {'stacked_object': 'block1', 'stacked_on': 'table'},
            {'stacked_object': 'block2', 'stacked_on': 'block1'},
        ]
    )
    tower_valid = result['valid']
    print(f"    Tower stacking valid: {tower_valid}")
    print(result)

    # Save visual evidence
    ops.save_all_screenshots(frame=10, subdir="tower_screenshots")
    ops.close()

    # Validate videos
    print("\n  Validating videos...")
    ops.validate_videos(timeout=180)
    video_result = ops.validate_video_files()

    # Print results
    videos_dir = Path(ops.experiment_dir) / "timeline" / "cameras"
    screenshots_dir = Path(ops.experiment_dir) / "tower_screenshots"

    print("\n" + "="*70)
    print("TOWER STACKING VALIDATION")
    print("="*70)
    print(f"\nScreenshots: {screenshots_dir}")
    print(f"Videos:      {videos_dir}")
    print(f"\nView Results:")
    print(f"  eog {screenshots_dir}/*.jpg")
    print(f"  vlc {videos_dir}/tower_close/tower_close_rgb.mp4")

    if tower_valid and video_result['valid']:
        print(f"\n‚úÖ PASS: Tower stacking complete! All 4 levels verified!")
        return True
    else:
        print(f"\n‚ùå FAIL: Tower validation failed")
        return False


def test_2_sorting_task():
    """Sorting Task: Fruits left, utensils right (categorical grouping)"""

    # Scene setup
    ops = ExperimentOps(mode="simulated", headless=True, render_mode="2k_demo", save_fps=30)
    ops.create_scene(name="sorting_scene", width=10, length=8, height=3)
    ops.add_robot(robot_name="stretch", position=(0, 0, 0))
    ops.add_asset(asset_name="table", relative_to=(2.5, 0.0, 0.0))

    # Initial state: all objects mixed in center
    ops.add_asset(asset_name="apple", relative_to="table", relation="on_top", surface_position="center")
    ops.add_asset(asset_name="banana", relative_to="apple", relation="next_to")
    ops.add_asset(asset_name="fork", name="fork", relative_to="banana", relation="next_to")
    ops.add_asset(asset_name="spoon", name="spoon", relative_to="fork", relation="next_to")

    # On-table rewards
    ops.add_reward(tracked_asset="apple", behavior="stacked_on", target="table", reward=50, id="apple_on_table")
    ops.add_reward(tracked_asset="banana", behavior="stacked_on", target="table", reward=50, id="banana_on_table")
    ops.add_reward(tracked_asset="fork", behavior="stacked_on", target="table", reward=50, id="fork_on_table")
    ops.add_reward(tracked_asset="spoon", behavior="stacked_on", target="table", reward=50, id="spoon_on_table")

    # Categorical clustering rewards
    ops.add_reward(tracked_asset="apple", behavior="next_to", target="banana", reward=100, id="fruits_grouped")
    ops.add_reward(tracked_asset="fork", behavior="next_to", target="spoon", reward=100, id="utensils_grouped")

    # Mixed group penalties
    ops.add_reward(tracked_asset="apple", behavior="next_to", target="fork", reward=-50, id="mixed_penalty_1")
    ops.add_reward(tracked_asset="banana", behavior="next_to", target="spoon", reward=-50, id="mixed_penalty_2")

    # Cameras
    ops.add_overhead_camera()
    ops.add_free_camera(camera_id="sorting_side", lookat=(2.5, 0.0, 0.8), distance=4.0, azimuth=90, elevation=-20)

    ops.compile()
    for _ in range(300):
        ops.step()
    ops.close()


def test_3_container_filling():
    """Container Filling: 3 small fruits inside bowl (containment relation)"""

    # Scene setup
    ops = ExperimentOps(mode="simulated", headless=True, render_mode="2k_demo", save_fps=30)
    ops.create_scene(name="container_scene", width=6, length=6, height=3)
    ops.add_robot(robot_name="stretch", position=(0, 0, 0))
    ops.add_asset(asset_name="table", relative_to=(2.0, 0.0, 0.0))

    # Bowl container
    ops.add_asset(asset_name="bowl", relative_to="table", relation="on_top", surface_position="center")

    # Fruits inside bowl (semantic "inside" relation)
    ops.add_asset(asset_name="cherry", name="cherry", relative_to="bowl", relation="inside", surface_position="bottom")
    ops.add_asset(asset_name="grape", name="grape", relative_to="bowl", relation="inside", surface_position="bottom")
    ops.add_asset(asset_name="blueberry", name="blueberry", relative_to="bowl", relation="inside", surface_position="bottom")

    # Bowl stability
    ops.add_reward(tracked_asset="bowl", behavior="stacked_on", target="table", reward=50, id="bowl_on_table")

    # Containment rewards (reciprocal relationship)
    ops.add_reward(tracked_asset="bowl", behavior="containing", target="cherry", reward=100, id="bowl_contains_cherry")
    ops.add_reward(tracked_asset="bowl", behavior="containing", target="grape", reward=100, id="bowl_contains_grape")
    ops.add_reward(tracked_asset="bowl", behavior="containing", target="blueberry", reward=100, id="bowl_contains_blueberry")

    # Escape penalties
    ops.add_reward(tracked_asset="cherry", behavior="stacked_on", target="table", reward=-50, id="cherry_escaped")
    ops.add_reward(tracked_asset="grape", behavior="stacked_on", target="table", reward=-50, id="grape_escaped")
    ops.add_reward(tracked_asset="blueberry", behavior="stacked_on", target="floor", reward=-100, id="blueberry_fell")

    # Cameras with interior view
    ops.add_overhead_camera()
    ops.add_free_camera(camera_id="bowl_interior", track_target="bowl", distance=0.8, azimuth=90, elevation=-45)
    ops.add_free_camera(camera_id="bowl_side", lookat=(2.0, 0.0, 0.8), distance=2.0, azimuth=135, elevation=-20)

    ops.compile()
    for _ in range(400):
        ops.step()
    ops.close()


def test_4_domino_chain():
    """Domino Chain: 5 dominoes cascade (inverse stability - want falling!)"""

    # Scene setup with higher FPS for dynamic motion
    ops = ExperimentOps(mode="simulated", headless=True, render_mode="2k_demo", save_fps=60)
    ops.create_scene(name="domino_scene", width=12, length=4, height=2)
    ops.add_robot(robot_name="stretch", position=(0, 0, 0))

    # Domino chain with precise spacing
    ops.add_asset(asset_name="domino", name="domino_1", relative_to=(3.0, 0.0, 0.0))
    ops.add_asset(asset_name="domino", name="domino_2", relative_to="domino_1", relation="next_to", spacing=0.15)
    ops.add_asset(asset_name="domino", name="domino_3", relative_to="domino_2", relation="next_to", spacing=0.15)
    ops.add_asset(asset_name="domino", name="domino_4", relative_to="domino_3", relation="next_to", spacing=0.15)
    ops.add_asset(asset_name="domino", name="domino_5", relative_to="domino_4", relation="next_to", spacing=0.15)

    # Cascade tracking: WANT dominoes to fall (inverse stability!)
    ops.add_reward(tracked_asset="domino_1", behavior="stable", target=False, reward=20, id="domino_1_fell")
    ops.add_reward(tracked_asset="domino_2", behavior="stable", target=False, reward=20, id="domino_2_fell")
    ops.add_reward(tracked_asset="domino_3", behavior="stable", target=False, reward=20, id="domino_3_fell")
    ops.add_reward(tracked_asset="domino_4", behavior="stable", target=False, reward=20, id="domino_4_fell")
    ops.add_reward(tracked_asset="domino_5", behavior="stable", target=False, reward=20, id="domino_5_fell")

    # Penalties for still standing
    ops.add_reward(tracked_asset="domino_2", behavior="stable", target=True, reward=-10, id="domino_2_standing")
    ops.add_reward(tracked_asset="domino_3", behavior="stable", target=True, reward=-10, id="domino_3_standing")
    ops.add_reward(tracked_asset="domino_5", behavior="stable", target=True, reward=-10, id="domino_5_standing")

    # Cameras follow cascade
    ops.add_free_camera(camera_id="follow_cascade", track_target="domino_3", distance=2.0, azimuth=90, elevation=-15)
    ops.add_overhead_camera()
    ops.add_free_camera(camera_id="domino_closeup", track_target="domino_1", distance=1.0, azimuth=45, elevation=-20)

    ops.compile()

    # Run simulation (robot action removed for now)
    for _ in range(300):
        ops.step()
    ops.close()


def test_5_balanced_shelf():
    """Balanced Shelf: Distribute 4 objects evenly to prevent tipping"""

    # Scene setup
    ops = ExperimentOps(mode="simulated", headless=True, render_mode="2k_demo", save_fps=30)
    ops.create_scene(name="balance_scene", width=8, length=6, height=3)
    ops.add_robot(robot_name="stretch", position=(0, 0, 0))
    ops.add_asset(asset_name="table", relative_to=(2.0, 0.0, 0.0))

    # Shelf on table
    ops.add_asset(asset_name="shelf", name="shelf", relative_to="table", relation="on_top", surface_position="center")

    # Balanced weight distribution across shelf
    ops.add_asset(asset_name="book", name="book_1", relative_to="shelf", relation="on_top", surface_position="left")
    ops.add_asset(asset_name="mug", name="mug", relative_to="shelf", relation="on_top", surface_position="right")
    ops.add_asset(asset_name="book", name="book_2", relative_to="shelf", relation="on_top", surface_position="center_left")
    ops.add_asset(asset_name="apple", relative_to="shelf", relation="on_top", surface_position="center_right")

    # Shelf stability rewards
    ops.add_reward(tracked_asset="shelf", behavior="stacked_on", target="table", reward=100, id="shelf_on_table")
    ops.add_reward(tracked_asset="shelf", behavior="stable", target=True, reward=50, id="shelf_stable")

    # Objects on shelf
    ops.add_reward(tracked_asset="book_1", behavior="stacked_on", target="shelf", reward=50, id="book1_on_shelf")
    ops.add_reward(tracked_asset="book_2", behavior="stacked_on", target="shelf", reward=50, id="book2_on_shelf")
    ops.add_reward(tracked_asset="mug", behavior="stacked_on", target="shelf", reward=50, id="mug_on_shelf")
    ops.add_reward(tracked_asset="apple", behavior="stacked_on", target="shelf", reward=50, id="apple_on_shelf")

    # Tipping penalty
    ops.add_reward(tracked_asset="shelf", behavior="stacked_on", target="floor", reward=-200, id="shelf_tipped")

    # Cameras
    ops.add_overhead_camera()
    ops.add_free_camera(camera_id="shelf_side", lookat=(2.0, 0.0, 0.8), distance=2.5, azimuth=90, elevation=-15)
    ops.add_free_camera(camera_id="shelf_front", lookat=(2.0, 0.0, 0.8), distance=2.0, azimuth=0, elevation=-20)

    ops.compile()
    for _ in range(500):
        ops.step()
    ops.close()


def test_6_nested_containers():
    """Nested Containers: Box ‚Üí Bowl ‚Üí Fruits (3-level containment hierarchy)"""

    # Scene setup
    ops = ExperimentOps(mode="simulated", headless=True, render_mode="2k_demo", save_fps=30)
    ops.create_scene(name="nesting_scene", width=6, length=6, height=3)
    ops.add_robot(robot_name="stretch", position=(0, 0, 0))
    ops.add_asset(asset_name="table", relative_to=(2.0, 0.0, 0.0))

    # Multi-level nesting
    ops.add_asset(asset_name="box", name="box", relative_to="table", relation="on_top", surface_position="center")
    ops.add_asset(asset_name="bowl", relative_to="box", relation="inside", surface_position="bottom")
    ops.add_asset(asset_name="cherry", name="cherry", relative_to="bowl", relation="inside", surface_position="bottom")
    ops.add_asset(asset_name="grape", name="grape", relative_to="bowl", relation="inside", surface_position="bottom")

    # Nested containment rewards
    ops.add_reward(tracked_asset="box", behavior="stacked_on", target="table", reward=50, id="box_on_table")
    ops.add_reward(tracked_asset="box", behavior="containing", target="bowl", reward=100, id="box_contains_bowl")
    ops.add_reward(tracked_asset="bowl", behavior="containing", target="cherry", reward=100, id="bowl_contains_cherry")
    ops.add_reward(tracked_asset="bowl", behavior="containing", target="grape", reward=100, id="bowl_contains_grape")

    # Broken nesting penalties
    ops.add_reward(tracked_asset="bowl", behavior="stacked_on", target="table", reward=-100, id="bowl_escaped_box")
    ops.add_reward(tracked_asset="cherry", behavior="stacked_on", target="box", reward=-50, id="cherry_escaped_bowl")

    # Cameras
    ops.add_overhead_camera()
    ops.add_free_camera(camera_id="box_interior", track_target="box", distance=1.0, azimuth=90, elevation=-45)
    ops.add_free_camera(camera_id="nesting_side", lookat=(2.0, 0.0, 0.8), distance=2.5, azimuth=135, elevation=-25)

    ops.compile()
    for _ in range(400):
        ops.step()
    ops.close()


if __name__ == "__main__":
    # Test menu
    tests = [
        ("Orientation Demo (robot + wood block)", test_0_breakfast_scene),
        ("Tower Stacking (4 blocks)", test_1_tower_stacking),
        # ("Sorting Task (categorical)", test_2_sorting_task),
        # ("Container Filling (inside relation)", test_3_container_filling),
        # ("Domino Chain (dynamic cascade)", test_4_domino_chain),
        # ("Balanced Shelf (weight distribution)", test_5_balanced_shelf),
        # ("Nested Containers (3-level)", test_6_nested_containers),
    ]

    print("\nü§ñ AI-Generated Scene Library")
    print("="*50)
    for i, (name, _) in enumerate(tests, 1):
        print(f"  {i}. {name}")

    choice = input(f"\nSelect (1-{len(tests)} or 'all'): ").strip().lower()

    if choice == "all":
        for _, test_func in tests:
            test_func()
    elif choice.isdigit() and 1 <= int(choice) <= len(tests):
        tests[int(choice) - 1][1]()
    else:
        print("Invalid choice")